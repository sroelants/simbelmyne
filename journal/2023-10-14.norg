Hmm, representing the board as a `HashMap<(Color, Piece), Position>` was kind of
a dumb idea. There's obviously more than one of each `(Color, Piece)`
combination in a board.

Wonder if I should just stick with a `Vec` of pieces for now.

Does each piece keep track of a bunch of bitboards? Or does the board keep
track of a vec of bitboards for each piece? (I.e., array of structs or struct of
arrays?)

I think, for now, it's probably easiest for each piece to keep track of its own
data. Can always optimize further down the line if I need to...


In that case, a `Piece` will become something closer to:
@code rust
enum PieceType { Pawn, Rook, Knight, Bishop, Queen, King }
enum Color { Black, White }
struct Position(u64);

struct Piece {
  color: Color,
  type: PieceType,
  position: Position,
}
@end

I'm not super happy about the parsing. Threading all the `nom` errors feels
super verbose. I'm sure I'll revisit this another couple of times as I go along

So, what are my next steps?

1. Have the program take commands? Prompt the user for commands in fully 
qualified algebraic, e.g., `Pe2 e4` (Or maybe even drop the piece? Simply 
`e2 e4`?
   


