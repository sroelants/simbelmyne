Guess the next step is generating /legal/ moves

That means:
1. Castling
2. En-passant
3. Checks (the tricky one...)
4. Make sure king can't get captured _after_ move

For that, I suppose I'd need to keep track of some additional metadata (the
remaining bits of information stored in the FEN string)
1. Castling rights
2. En passant pieces/squares

I imagine I also want to keep track of all the pieces that are putting the king
in check. So, when in check, I suppose I need to go over all possible moves, 
and check whether making them still leaves the king in check. If so, I can't
do that.

Slightly easier. Check that, after the move, the king is not on an attacked
square. 

* Castling
  This breaks down into two parts:
** Castling rights
   Basically, keep track of whether or not the king/rooks have moved. This only
   needs two bits per side, right? Or do we just shove it into an enum?
   @code rust
   enum CastlingRights {
     WK, WQ, BK, BQ
   }
   @end

   Kinda feels like a bitmask would do just fine here
   @code rust
   enum Castle {
       WQ = 0b0001,
       WK = 0b0010,
       BQ = 0b0100,
       BK = 0b1000,
   }
   struct CastlingRights(u8);

   impl CastlingRights {
     add(&mut self, castle: Castle) {
       self.0 = self.0 | castle;
     }

     remove(&mut self, castle: Castle) {
       self.0 = self.0 & !castle;
     }

      toggle(&mut self, castle: Castle) {
       self.0 = self.0 ^ !castle;
     }
   }
   @end

   That way, the `Board` can store the `CastlingRights`, and toggling the 
   castling rights can be as easy as CastlingRights.remove(CastlingRights::WQ)
