Trying to implement the basic board representation

* Board representation
  Right now thinking a board could just be a hash that maps piece types to 
  a bitboard (u64)

  How do we represent pieces, in that case?
  1) The easiest option is to simply store them as (Color, Piece) pairs
  2) There's 6 Piece types, so we could easily store it in a u8, with
    additional space to flag the color.
  3) At some point, we'll want to associate a unique u64 to every piece type,
    so we can do Zobrist hashing. Could we simply use those identifiers? Not
    sure, because the Zobrist ID encodes additional game state (can castle, 
    en-passant, etc...). 
    Though, I suppose we still /could/ do something like
    that, if we have separate unique hashes for the metadata. (That way, we have
    a hash for `white`, `rook` and `can-castle`, hashing them together to get 
    the required hash. I think I kinda like that approach.
    The actual pieces could be identified either by a u32 (one bit for every
    piece, though we'd need a bit of extra logic to map that back into something
    a little more readable, like a (Color, Piece) tuple


  Think I'll probably stick to representing pieces as a (Color, Piece) tuples

@code rust
struct Position(u64); // Bitboard representation
enum Piece {/*...*/};
enum Color { Black, White };

struct Board {
  pieces: HashMap<(Color, Piece)>
}
@end

  Probably good idea to start off by parsing FEN strings into a board
  configuration

  Next, I'll probably want a way to print out a board

  Dependencies I'll likely want to pull in:
  1. Nom for the parsing? Maybe not necessary, given how trivial FEN is
  2. crossbeam et al. for rendering to the terminal? (Maybe start off just 
     printing out a multiline string)
  3. An error library (anyhow? Eyre?)
