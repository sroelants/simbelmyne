//! Find all the legal moves for a given board state
//!
//! Moves are generated by piece type, so we can shortcut, e.g. when only the
//! king is allowed to move.
//!
//! All the move generating functions are parametrized by a `QUIETS` const
//! generic that decides whether or not to include quiet moves.

use arrayvec::ArrayVec;
use itertools::Itertools;

use crate::constants::RANKS;
use crate::movegen::castling::CastleType;
use crate::square::Square;
use crate::{
    bitboard::Bitboard,
    movegen::moves::MoveType,
};
use crate::board::Board;
use crate::movegen::lookups::{BETWEEN, RAYS};
use crate::movegen::moves::Move;
use crate::piece::PieceType;

use super::moves::BareMove;

const ALL: bool = true;

pub const MAX_MOVES: usize = 218;
pub type MoveList = ArrayVec<Move, MAX_MOVES>;

impl Board {
    /// Generate all the legal tactical moves for the current board state
    pub fn tacticals(&self, moves: &mut MoveList) {
        use MoveType::*;
        let us = self.current;
        let them = !us;
        let ours = self.occupied_by(us);
        let theirs = self.occupied_by(them);
        let blockers = ours | theirs;
        let checkers = self.get_checkers();
        let pinrays = self.pinrays[us as usize];
        let king_sq = self.kings(us).first();
        let in_check = checkers.count() > 0;
        let pinned_pieces = ours & pinrays;
        let promo_rank = self.get_promo_rank();

        ////////////////////////////////////////////////////////////////////////
        //
        // King tacticals
        //
        ////////////////////////////////////////////////////////////////////////

        for square in self.kings(us) {
            let mut visible = square.king_squares();

            // King can only move to squares that aren't attacked
            // The NO_KING parameter removes the king itself before calculating the
            // attacked squares, to make sure the king's not blocking any attacks.
            visible &= !self.get_threats();

            let captures = visible & theirs;

            for target in captures {
                moves.push(Move::new(square, target, Capture));
            }
        }

        // If we're in double check, only king moves are valid, so we exit 
        // early.
        if checkers.count() > 1 {
            return;
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // Piece tacticals
        //
        ////////////////////////////////////////////////////////////////////////

        use PieceType::*;
        for square in self.pieces(us) {
            let piece = self.get_at(square).unwrap();
            let is_pinned = pinned_pieces.contains(square);

            let mut visible = match piece.piece_type() {
                Knight => square.knight_squares(),
                Bishop => square.bishop_squares(blockers),
                Rook => square.rook_squares(blockers),
                Queen => square.queen_squares(blockers),
                _ => unreachable!()
            };

            // If we're pinned, we can't move outside of our pin-ray
            if is_pinned {
                let pinray = pinrays & RAYS[king_sq as usize][square as usize];
                visible &= pinray;
            }

            let mut captures = visible & theirs;

            if in_check {
                captures &= checkers;
            }

            for target in captures {
                moves.push(Move::new(square, target, Capture));
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // Pawn tacticals
        //
        ////////////////////////////////////////////////////////////////////////

        for square in self.pawns(us) {
            let is_pinned = pinned_pieces.contains(square);

            let mut visible = square.pawn_squares(us, blockers) 
                | square.pawn_attacks(us) & theirs;

            // If we're pinned, we can't move outside of our pin-ray
            if is_pinned {
                let pinray = pinrays & RAYS[king_sq as usize][square as usize];
                visible &= pinray;
            }

            let mut captures       = visible &  theirs   & !promo_rank;
            let mut promo_captures = visible &  theirs   &  promo_rank;
            let mut promos         = visible & !blockers &  promo_rank;

            if in_check {
                // In check, the only legal captures capture the checker
                captures &= checkers;
                promo_captures &= checkers;

                // In check, the only legal promotions block the checker
                let checker_sq = checkers.first();
                promos &= BETWEEN[checker_sq as usize][king_sq as usize];
            }

            for target in captures {
                moves.push(Move::new(square, target, Capture));
            }

            for target in promo_captures {
                moves.push(Move::new(square, target, KnightPromoCapture));
                moves.push(Move::new(square, target, BishopPromoCapture));
                moves.push(Move::new(square, target, RookPromoCapture));
                moves.push(Move::new(square, target, QueenPromoCapture));
            }

            for target in promos {
                moves.push(Move::new(square, target, KnightPromo));
                moves.push(Move::new(square, target, BishopPromo));
                moves.push(Move::new(square, target, RookPromo));
                moves.push(Move::new(square, target, QueenPromo));
            }

            // Add potential en-passant moves, after making sure they don't lead
            // to discovered checks
            if self.en_passant.is_some() && !is_pinned {
                if let Some(mv) = self.en_passant_move(square, checkers) {
                    moves.push(mv);
                }
            }
        }
    }

    /// Generate all the legal quiet moves for the current board state
    pub fn quiets(&self, moves: &mut MoveList) {
        use MoveType::*;
        let us = self.current;
        let them = !us;
        let ours = self.occupied_by(us);
        let theirs = self.occupied_by(them);
        let blockers = ours | theirs;
        let checkers = self.get_checkers();
        let pinrays = self.pinrays[us as usize];
        let king_sq = self.kings(us).first();
        let in_check = checkers.count() > 0;
        let pinned_pieces = ours & pinrays;
        let promo_rank = self.get_promo_rank();

        ////////////////////////////////////////////////////////////////////////
        //
        // King quiets
        //
        ////////////////////////////////////////////////////////////////////////

        for square in self.kings(us) {
            let mut visible = square.king_squares();

            // King can only move to squares that aren't attacked
            // The NO_KING parameter removes the king itself before calculating the
            // attacked squares, to make sure the king's not blocking any attacks.
            visible &= !self.get_threats();

            let quiets = visible & !blockers;

            for target in quiets {
                moves.push(Move::new(square, target, Quiet));
            }

            // Add castling moves
            for ctype in self.legal_castles() {
                moves.push(ctype.king_move());
            }
        }

        // If we're in double check, only king moves are valid, so we exit 
        // early.
        if checkers.count() > 1 {
            return;
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // Piece quiets
        //
        ////////////////////////////////////////////////////////////////////////

        use PieceType::*;
        for square in self.pieces(us) {
            let is_pinned = pinned_pieces.contains(square);
            let piece = self.get_at(square).unwrap();

            let mut visible = match piece.piece_type() {
                Knight => square.knight_squares(),
                Bishop => square.bishop_squares(blockers),
                Rook => square.rook_squares(blockers),
                Queen => square.queen_squares(blockers),
                _ => unreachable!()
            };

            // If we're pinned, we can't move outside of our pin-ray
            if is_pinned {
                let pinray = pinrays & RAYS[king_sq as usize][square as usize];
                visible &= pinray;
            }

            let mut quiets = visible & !blockers;

            // If we're in check, blocking is the only valid option
            if in_check {
                let checker_sq = checkers.first();
                quiets &= BETWEEN[checker_sq as usize][king_sq as usize];
            }

            for target in quiets {
                moves.push(Move::new(square, target, Quiet));
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // Pawn quiets
        //
        ////////////////////////////////////////////////////////////////////////

        for square in self.pawns(us) {
            let is_pinned = pinned_pieces.contains(square);

            let mut visible = square.pawn_squares(us, blockers) 
                | square.pawn_attacks(us) & theirs;

            // If we're pinned, we can't move outside of our pin-ray
            if is_pinned {
                let pinray = pinrays & RAYS[king_sq as usize][square as usize];
                visible &= pinray;
            }

            let mut quiets = visible & !blockers & !promo_rank;

            // If we're in check, blocking is the only valid option
            if in_check {
                let checker_sq = checkers.first();
                quiets &= BETWEEN[checker_sq as usize][king_sq as usize];
            }

            // Push a move for every target square
            for target in quiets {
                if square.distance(target) == 2 {
                    moves.push(Move::new(square, target, DoublePush));
                } else {
                    moves.push(Move::new(square, target, Quiet));
                }
            }
        }
    }

    /// Find all the legal moves for the current board state
    pub fn legal_moves<const ALL: bool>(&self) -> MoveList {
        let mut moves = MoveList::new();

        self.tacticals(&mut moves);

        if ALL {
            self.quiets(&mut moves);
        }

        moves
    }

    /// If there's a valid EP move, add it to the moves buffer
    fn en_passant_move(
        &self, 
        square: Square, 
        checkers: Bitboard
    ) -> Option<Move> {
        let us = self.current;
        let ep_sq = self.en_passant.unwrap();
        let in_check = checkers.count() > 0;
        let attacked_sq = ep_sq.backward(us).unwrap();

        // See if we can capture in the first place
        let can_capture = square.pawn_attacks(us).contains(ep_sq);

        if !can_capture {
            return None;
        }

        // If we're in check, EP is only allowed if the pawn we're trying to 
        // capture happens to be the checker.
        if in_check && !checkers.contains(attacked_sq) {
            return None;
        }

        // Make sure the capture doesn't lead to a discovered check.
        let cleared_rank = RANKS[square.rank()];
        let source = Bitboard::from(square);
        let captured = Bitboard::from(attacked_sq);
        let invisible = source | captured;
        let xray_checkers = self.xray_checkers(us, invisible);
        let exposes_check = !xray_checkers
            .overlap(cleared_rank)
            .is_empty();

        if exposes_check {
            return None;
        }

        Some(Move::new(square, ep_sq, MoveType::EnPassant))
    }

    // Find a legal move corresponding to an un-annotated bare move, if any.
    pub fn find_move(&self, bare: BareMove) -> Option<Move> {
        let legals = self.legal_moves::<ALL>();
        legals.into_iter().find(|legal| legal.eq(&bare))
    }

    /// Check whether a move is legal to play in the current board position.
    ///
    /// This aims to be a lot cheaper than simply generating all the legal moves
    /// and checking whether the provided move is among them.
    ///
    /// This assumes the moves were generated by some kind of legal movegen. 
    /// For example, we assume that promotions and castling happen on the 
    /// 1st/8th ranks.
    pub fn is_legal(&self, mv: Move) -> Result<(), &'static str> {
        use PieceType::*;
        let us = self.current;
        let checkers = self.get_checkers();
        let num_checkers = checkers.count();
        let pinrays = self.get_pinrays(us);
        let blockers = self.all_occupied();
        let src = mv.src();
        let tgt = mv.tgt();

        ///////////////////////////////////////////////////////////////////////
        //
        // Pseudolegality checks
        //
        // A pseudolegal move is a valid move, but might leave the king in
        // check.
        //
        ///////////////////////////////////////////////////////////////////////

        // There is a piece on the starting square
        let Some(piece) = self.get_at(src) else { return Err("There is no piece at starting square"); };

        // The piece is the correct color
        if piece.color() != us {
            return Err("Moved piece is the wrong color");
        }

        // Make sure the move is pseudo-legal. 
        let attacked = match piece.piece_type() {
            Pawn => if mv.is_capture() {
                src.pawn_attacks(us)
            } else {
                src.pawn_squares(us, blockers)
            },
            Knight => src.knight_squares(),
            Bishop => src.bishop_squares(blockers),
            Rook => src.rook_squares(blockers),
            Queen => src.queen_squares(blockers),
            King => src.king_squares(),
        };

        if !attacked.contains(tgt) && !mv.is_castle() && !mv.is_en_passant() {
            return Err("Target square not among the piece's allowed moves");
        }

        if mv.is_en_passant() {
            // Moved piece must be a pawn
            if !piece.is_pawn() {
                return Err("Move flagged en-passant, but piece is not a pawn");
            }

            // Ep square must be set
            if self.en_passant.is_none() {
                return Err("Move is flagged en-passant, but there is no EP square");
            }

            // If ep square is set, target _must_ be the ep square
            if let Some(ep_sq) = self.en_passant {
                if ep_sq != tgt {
                    return Err("Move is flagged en-passant, but target is not the EP square");
                }

                if !attacked.contains(ep_sq) {
                    return Err("Move is flagged en-passant, but ep square is not among attacked squares");
                }
            }
        }

        // Capture checks
        let captured = self.get_at(mv.get_capture_sq());

        if let Some(captured) = captured {
            // If there's a captured piece, the move must be marked as a capture
            if !mv.is_capture() {
                return Err("There's a captured piece, but piece is not flagged as capture");
            }

            // If there's a captured piece, it must be the opponent's color
            if captured.color() == us {
                return Err("There's a captured piece but it's the wrong color");
            }
        } else {
            // If no piece was captured, it shouldn't be flagged as a capture
            if mv.is_capture() {
                return Err("No piece was captured, but move was flagged as capture");
            }
        }

        // En passant checks
        if mv.is_en_passant() {
            // Captured piece must be a pawn
            if !captured.is_some_and(|piece| piece.is_pawn()) {
                return Err("Move is flagged en-passant, but captured piece is not a pawn");
            }
        }

        // Promotion checks
        if mv.is_promotion() {
            if !piece.is_pawn() {
                return Err("Move is flagged as promotion, but piece is not a pawn");
            }

            if !self.get_promo_rank().contains(tgt) {
                return Err("Move is flagged as promotion, but target is not promo rank");
            }
        }

        // Double push checks
        if mv.is_double_push() {
            if !piece.is_pawn() {
                return Err("Move is flagged double push, but piece is not a pawn");
            }

            if us.is_white() && src.rank() != 1 {
                return Err("Move is flagged double push, but rank is not starting rank");
            }

            if us.is_black() && src.rank() != 6 {
                return Err("Move is flagged double push, but rank is not starting rank");
            }

            if src.max_dist(tgt) != 2 {
                return Err("Move is flagged double push, but distance is not 2 squares");
            }
        }

        // Castle checks
        if mv.is_castle() {
            // The move is a valid castle move
            let Some(ctype) = CastleType::from_move(mv) else {
                return Err("Move is flagged castle, move is not a valid castle move");
            };

            // The move flag matches the castle type
            use CastleType::*;
            match ctype {
                WK | BK if mv.get_type() != MoveType::KingCastle => 
                    return Err("Castle type is kingside, but move flagged as something else"),
                WQ | BQ if mv.get_type() != MoveType::QueenCastle => 
                    return Err("Castle type is kingside, but move flagged as something else"),
                _ => {}
            };

            // Can't castle when in check
            if num_checkers > 0 {
                return Err("Move is flagged castle, but king is in check");
            }

            // Castle must move the king
            if !piece.is_king() {
                return Err("Move is flagged castle, but piece is not the king");
            }

            // Castle must be available, unobstructed and not attacked
            if !self.legal_castles().contains(&ctype) {
                return Err("Move is flagged castle, but castle is not legal");
            }
        }

        // Pawn checks 
        if piece.is_pawn() && tgt.is_promo_rank(self.current) && !mv.is_promotion() {
            return Err("Pawn move to promo rank, but move is not flagged as promotion");
        }

        // A pawn move of 2 squares must be flagged as a double push
        if piece.is_pawn() && src.max_dist(tgt) == 2 && !mv.is_double_push() {
            return Err("Pawn moved 2 squares, but move is not flagged as double push");
        }

        ///////////////////////////////////////////////////////////////////////
        //
        // Legality checks
        //
        // Verify that the king is not left in check. This deals with pins,
        // double checks, etc...
        //
        //
        ///////////////////////////////////////////////////////////////////////

        // Only king moves allowed when double checked
        if num_checkers > 1 {
            if !piece.is_king() {
                return Err("Double check, but moved piece is not the king");
            }
        }

        // If piece is pinned, make sure target square is inside pinray
        let king_sq = self.kings(self.current).first();

        if pinrays.contains(src) && !(pinrays & RAYS[king_sq as usize][src as usize]).contains(tgt) {
            return Err("Piece is pinned, but target is not in pinray");
        }

        // If in check, make sure the target square is between the king and the
        // checker
        if let Some(checker) = checkers.into_iter().next() {
            let king = self.kings(us).first();

            if !piece.is_king() && !BETWEEN[king as usize][checker as usize].contains(tgt) {
                return Err("King is in check, but target square does not block the check");
            }
        }

        // EP-revealed checks
        if mv.is_en_passant() {
            let post_ep_blockers = blockers 
                ^ Bitboard::from(src)
                ^ Bitboard::from(tgt)
                ^ Bitboard::from(self.en_passant.unwrap());
            let king = self.kings(us).first();

            let post_ep_check = !(
                (king.rook_squares(post_ep_blockers) & self.hv_sliders(!us)).is_empty()
             && (king.bishop_squares(post_ep_blockers) & self.diag_sliders(!us)).is_empty()
            );

            if post_ep_check {
                return Err("En-passant capture would expose a check");
            }
        }

        // King can't move into check
        if piece.is_king() && self.threats.contains(tgt) {
            return Err("King move to an attacked square");
        }

        Ok(())
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// Tests
//
////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use std::collections::{BTreeSet, HashSet};

    use super::*;
    use crate::square::Square;
    use itertools::Itertools;
    use Square::*;
    

    #[test]
    fn double_pushes() {
        let board: Board = "rnbqkbnr/ppp1pppp/3p4/8/8/3P4/PPP1PPPP/RNBQKBNR w KQkq - 0 2"
            .parse()
            .unwrap();
        let legal_moves = board.legal_moves::<ALL>();

        // e2 can double-push
        assert!(legal_moves
            .iter()
            .find(|mv| mv.src() == Square::E2 && mv.tgt() == Square::E4 && mv.is_double_push())
            .is_some());

        // d3 can't double-push
        assert!(legal_moves
            .iter()
            .find(|mv| mv.src() == Square::D3 && mv.tgt() == Square::D5)
            .is_none());
    }

    #[test]
    fn pieces_must_block_to_counter_checks() {
        let board: Board = "1k6/8/8/5q2/8/8/4R3/1K6 w - - 0 1".parse().unwrap();
        let legal_moves = board.legal_moves::<ALL>();

        let rook_moves: Vec<Move> = legal_moves
            .into_iter()
            .filter(|mv| mv.src() == Square::E2)
            .collect();

        // Only two legal moves: block on c2 or e4
        assert_eq!(rook_moves.len(), 2);
        assert!(rook_moves
            .iter()
            .find(|mv| mv.tgt() == Square::C2)
            .is_some());
        assert!(rook_moves
            .iter()
            .find(|mv| mv.tgt() == Square::E4)
            .is_some())
    }

    #[test]
    fn king_must_move_out_of_check() {
        let board: Board = "1k6/8/8/5q2/8/3K4/8/8 w - - 0 1".parse().unwrap();
        let king_moves: Vec<Move> = board
            .legal_moves::<ALL>()
            .into_iter()
            .filter(|mv| mv.src() == Square::D3)
            .collect();

        // Only king moves are getting out of check
        assert_eq!(king_moves.len(), 6);
        assert!(king_moves
            .iter()
            .find(|mv| mv.tgt() == Square::E4)
            .is_none());
        assert!(king_moves
            .iter()
            .find(|mv| mv.tgt() == Square::C2)
            .is_none());
    }

    #[test]
    fn check_blocks_and_king_moves_combined() {
        let board: Board = "1k6/8/8/5q2/8/4P3/PP5r/RK6 w - - 0 1".parse().unwrap();
        let legal_moves = board.legal_moves::<ALL>();
        let king_moves: Vec<&Move> = legal_moves
            .iter()
            .filter(|mv| mv.src() == Square::B1)
            .collect();

        let pawn_moves: Vec<&Move> = legal_moves
            .iter()
            .filter(|mv| mv.src() == Square::E3)
            .collect();

        // Only legal moves are Kc1 and e4
        assert_eq!(legal_moves.len(), 2);

        // King's only move is c1
        assert_eq!(king_moves.len(), 1);
        assert_eq!(king_moves.first().unwrap().tgt(), Square::C1);

        // Pawn's only move is e4
        assert_eq!(pawn_moves.len(), 1);
        assert_eq!(pawn_moves.first().unwrap().tgt(), Square::E4);
    }

    #[test]
    fn pins() {
        let board: Board = "1k6/2q5/8/1n6/5B2/1R6/8/1K6 b - - 0 1".parse().unwrap();
        let legal_moves = board.legal_moves::<ALL>();

        let knight_moves: Vec<&Move> = legal_moves.iter().filter(|mv| mv.src() == B5).collect();

        let queen_moves: Vec<&Move> = legal_moves.iter().filter(|mv| mv.src() == C7).collect();

        // Knight is completely pinned
        assert_eq!(knight_moves.len(), 0);

        // Queen can move within the pin ray
        assert_eq!(queen_moves.len(), 3);
    }

    #[test]
    fn en_passant() {
        let board: Board = "1k6/8/8/8/3Pp3/8/8/1K6 b - d3 0 1".parse().unwrap();
        let legal_moves = board.legal_moves::<ALL>();

        let pawn_moves: Vec<&Move> = legal_moves.iter().filter(|mv| mv.src() == E4).collect();

        assert_eq!(pawn_moves.len(), 2, "there are two legal pawn moves from e4");

        let en_passant = pawn_moves.iter().find(|mv| mv.tgt() == D3);
        assert!(en_passant.is_some(), "We can capture en-passant");
        assert!(
            en_passant.unwrap().is_en_passant(),
            "The en-passant flag is set"
        );
    }

    #[test]
    fn en_passant_revealed_check() {
        let board: Board = "8/8/8/8/k2Pp2R/8/8/K7 b - d3 0 1".parse().unwrap();
        let legal_moves = board.legal_moves::<ALL>();

        let pawn_moves: Vec<&Move> = legal_moves.iter().filter(|mv| mv.src() == E4).collect();

        let en_passant = pawn_moves.iter().find(|mv| mv.tgt() == D3);
        assert!(
            en_passant.is_none(),
            "En-passant not allowed if it reveals a check"
        );
    }

    // Legal moves tests

    // #[test]
    // /// A legal move has a piece on its starting square
    // fn is_legal_piece_on_starting_square() {
    //     let board = Board::default();
    //     let mv = Move::new(E3, E4, MoveType::Quiet);
    //
    //     assert!(!board.is_legal(mv));
    // }
    //
    // #[test]
    // /// A legal move's piece has the correct color
    // fn is_legal_piece_correct_color() {
    //     let board = Board::default();
    //     let mv = Move::new(E7, E5, MoveType::Quiet);
    //
    //     assert!(!board.is_legal(mv));
    // }
    //
    // #[test]
    // /// A legal capture has a captured piece on the "capture" square
    // fn is_legal_captured_piece() {
    //     let board = Board::default();
    //     let mv = Move::new(A1, A4, MoveType::Capture);
    //
    //     assert!(!board.is_legal(mv));
    // }
    //
    // #[test]
    // /// A legal capture's captured piece is one of the opponent's pieces
    // fn is_legal_captured_piece_correct_color() {
    //     let board = Board::default();
    //     let mv = Move::new(A1, A2, MoveType::Capture);
    //
    //     assert!(!board.is_legal(mv));
    // }

    const TEST_POSITIONS: [&'static str; 50] = [
    "r3k2r/2pb1ppp/2pp1q2/p7/1nP1B3/1P2P3/P2N1PPP/R2QK2R w KQkq a6 0 14",
    "4rrk1/2p1b1p1/p1p3q1/4p3/2P2n1p/1P1NR2P/PB3PP1/3R1QK1 b - - 2 24",
    "r3qbrk/6p1/2b2pPp/p3pP1Q/PpPpP2P/3P1B2/2PB3K/R5R1 w - - 16 42",
    "6k1/1R3p2/6p1/2Bp3p/3P2q1/P7/1P2rQ1K/5R2 b - - 4 44",
    "8/8/1p2k1p1/3p3p/1p1P1P1P/1P2PK2/8/8 w - - 3 54",
    "7r/2p3k1/1p1p1qp1/1P1Bp3/p1P2r1P/P7/4R3/Q4RK1 w - - 0 36",
    "r1bq1rk1/pp2b1pp/n1pp1n2/3P1p2/2P1p3/2N1P2N/PP2BPPP/R1BQ1RK1 b - - 2 10",
    "3r3k/2r4p/1p1b3q/p4P2/P2Pp3/1B2P3/3BQ1RP/6K1 w - - 3 87",
    "2r4r/1p4k1/1Pnp4/3Qb1pq/8/4BpPp/5P2/2RR1BK1 w - - 0 42",
    "4q1bk/6b1/7p/p1p4p/PNPpP2P/KN4P1/3Q4/4R3 b - - 0 37",
    "2q3r1/1r2pk2/pp3pp1/2pP3p/P1Pb1BbP/1P4Q1/R3NPP1/4R1K1 w - - 2 34",
    "1r2r2k/1b4q1/pp5p/2pPp1p1/P3Pn2/1P1B1Q1P/2R3P1/4BR1K b - - 1 37",
    "r3kbbr/pp1n1p1P/3ppnp1/q5N1/1P1pP3/P1N1B3/2P1QP2/R3KB1R b KQkq b3 0 17",
    "8/6pk/2b1Rp2/3r4/1R1B2PP/P5K1/8/2r5 b - - 16 42",
    "1r4k1/4ppb1/2n1b1qp/pB4p1/1n1BP1P1/7P/2PNQPK1/3RN3 w - - 8 29",
    "8/p2B4/PkP5/4p1pK/4Pb1p/5P2/8/8 w - - 29 68",
    "3r4/ppq1ppkp/4bnp1/2pN4/2P1P3/1P4P1/PQ3PBP/R4K2 b - - 2 20",
    "5rr1/4n2k/4q2P/P1P2n2/3B1p2/4pP2/2N1P3/1RR1K2Q w - - 1 49",
    "1r5k/2pq2p1/3p3p/p1pP4/4QP2/PP1R3P/6PK/8 w - - 1 51",
    "q5k1/5ppp/1r3bn1/1B6/P1N2P2/BQ2P1P1/5K1P/8 b - - 2 34",
    "r1b2k1r/5n2/p4q2/1ppn1Pp1/3pp1p1/NP2P3/P1PPBK2/1RQN2R1 w - - 0 22",
    "r1bqk2r/pppp1ppp/5n2/4b3/4P3/P1N5/1PP2PPP/R1BQKB1R w KQkq - 0 5",
    "r1bqr1k1/pp1p1ppp/2p5/8/3N1Q2/P2BB3/1PP2PPP/R3K2n b Q - 1 12",
    "r1bq2k1/p4r1p/1pp2pp1/3p4/1P1B3Q/P2B1N2/2P3PP/4R1K1 b - - 2 19",
    "r4qk1/6r1/1p4p1/2ppBbN1/1p5Q/P7/2P3PP/5RK1 w - - 2 25",
    "r7/6k1/1p6/2pp1p2/7Q/8/p1P2K1P/8 w - - 0 32",
    "r3k2r/ppp1pp1p/2nqb1pn/3p4/4P3/2PP4/PP1NBPPP/R2QK1NR w KQkq - 1 5",
    "3r1rk1/1pp1pn1p/p1n1q1p1/3p4/Q3P3/2P5/PP1NBPPP/4RRK1 w - - 0 12",
    "5rk1/1pp1pn1p/p3Brp1/8/1n6/5N2/PP3PPP/2R2RK1 w - - 2 20",
    "8/1p2pk1p/p1p1r1p1/3n4/8/5R2/PP3PPP/4R1K1 b - - 3 27",
    "8/4pk2/1p1r2p1/p1p4p/Pn5P/3R4/1P3PP1/4RK2 w - - 1 33",
    "8/5k2/1pnrp1p1/p1p4p/P6P/4R1PK/1P3P2/4R3 b - - 1 38",
    "8/8/1p1kp1p1/p1pr1n1p/P6P/1R4P1/1P3PK1/1R6 b - - 15 45",
    "8/8/1p1k2p1/p1prp2p/P2n3P/6P1/1P1R1PK1/4R3 b - - 5 49",
    "8/8/1p4p1/p1p2k1p/P2npP1P/4K1P1/1P6/3R4 w - - 6 54",
    "8/8/1p4p1/p1p2k1p/P2n1P1P/4K1P1/1P6/6R1 b - - 6 59",
    "8/5k2/1p4p1/p1pK3p/P2n1P1P/6P1/1P6/4R3 b - - 14 63",
    "8/1R6/1p1K1kp1/p6p/P1p2P1P/6P1/1Pn5/8 w - - 0 67",
    "1rb1rn1k/p3q1bp/2p3p1/2p1p3/2P1P2N/PP1RQNP1/1B3P2/4R1K1 b - - 4 23",
    "4rrk1/pp1n1pp1/q5p1/P1pP4/2n3P1/7P/1P3PB1/R1BQ1RK1 w - - 3 22",
    "r2qr1k1/pb1nbppp/1pn1p3/2ppP3/3P4/2PB1NN1/PP3PPP/R1BQR1K1 w - - 4 12",
    "2r2k2/8/4P1R1/1p6/8/P4K1N/7b/2B5 b - - 0 55",
    "6k1/5pp1/8/2bKP2P/2P5/p4PNb/B7/8 b - - 1 44",
    "2rqr1k1/1p3p1p/p2p2p1/P1nPb3/2B1P3/5P2/1PQ2NPP/R1R4K w - - 3 25",
    "r1b2rk1/p1q1ppbp/6p1/2Q5/8/4BP2/PPP3PP/2KR1B1R b - - 2 14",
    "6r1/5k2/p1b1r2p/1pB1p1p1/1Pp3PP/2P1R1K1/2P2P2/3R4 w - - 1 36",
    "rnbqkb1r/pppppppp/5n2/8/2PP4/8/PP2PPPP/RNBQKBNR b KQkq c3 0 2",
    "2rr2k1/1p4bp/p1q1p1p1/4Pp1n/2PB4/1PN3P1/P3Q2P/2RR2K1 w - f6 0 20",
    "3br1k1/p1pn3p/1p3n2/5pNq/2P1p3/1PN3PP/P2Q1PB1/4R1K1 w - - 0 23",
    "2r2b2/5p2/5k2/p1r1pP2/P2pB3/1P3P2/K1P3R1/7R w - - 23 93",
    ];

    #[test]
    fn is_legal_test_suite() {
        for fen in TEST_POSITIONS {
            let board: Board = fen.parse().unwrap();
            let legal_moves = board.legal_moves::<true>();

            for mv in 0..u16::MAX {
                let mv = Move::from(mv);
                let result = board.is_legal(mv);

                let expected = legal_moves.iter().any(|&legal| {
                    legal.src() == mv.src()
                    && legal.tgt() == mv.tgt()
                    && legal.get_type() == mv.get_type()
                });

                if result.is_ok() != expected {
                    println!("{board}");

                    println!(
                        "Move: {}{} ({:?}), is_legal returned: {}, expected: {expected}", 
                        mv.src(), 
                        mv.tgt(), 
                        mv.get_type(),
                        result.is_ok(),
                    );

                    if let Err(msg) = result {
                        println!("Illegal: {msg}");
                    }

                    assert_eq!(result.is_ok(), expected);
                }
            }
        }
    }

    fn perft_test(depth: usize, current_board: Board, original: &Board, legal_moves: &BTreeSet<Move>) {
        for mv in current_board.legal_moves::<true>() {
            // let result = original.is_legal(mv);
            // let expected = legal_moves.contains(&mv);
            //
            // // Check whether move is legal when played in the original position
            // if result.is_ok() != expected {
            //     println!("{original}");
            //     println!("Move: {}{} ({:?}), is_legal: {}, actually: {}",
            //         mv.src(),
            //         mv.tgt(),
            //         mv.get_type(),
            //         result.is_ok(),
            //         expected
            //     );
            //
            //     if let Err(msg) = result {
            //         println!("{msg}");
            //     }
            // }

            // Recurse if we're not at the requested depth yet
            let new_board = current_board.play_move(mv);
            if depth > 0 {
                perft_test(depth - 1, new_board, original, legal_moves);
            }
        }
    }

    #[test]
    fn is_legal_perft() {
        for fen in TEST_POSITIONS {
            let board: Board = fen.parse().unwrap();
            let legal_moves = BTreeSet::from_iter(board.legal_moves::<true>().into_iter());

            perft_test(5, board, &board, &legal_moves);
        }
    }
}
