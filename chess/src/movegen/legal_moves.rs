//! Find all the legal moves for a given board state
//!
//! Moves are generated by piece type, so we can shortcut, e.g. when only the
//! king is allowed to move.
//!
//! All the move generating functions are parametrized by a `QUIETS` const
//! generic that decides whether or not to include quiet moves.

use arrayvec::ArrayVec;
use itertools::Itertools;

use crate::constants::RANKS;
use crate::movegen::castling::CastleType;
use crate::{
    bitboard::Bitboard,
    movegen::moves::MoveType,
};
use crate::board::Board;
use crate::movegen::lookups::{BETWEEN, RAYS};
use crate::movegen::moves::Move;
use crate::piece::PieceType;

use super::moves::BareMove;

const ALL: bool = true;

pub const MAX_MOVES: usize = 218;
pub type MoveList = ArrayVec<Move, MAX_MOVES>;

impl Board {
    /// Generate all the legal tactical moves for the current board state
    pub fn tacticals(&self, moves: &mut MoveList) {
        use MoveType::*;
        let us = self.current;
        let them = !us;
        let ours = self.occupied_by(us);
        let theirs = self.occupied_by(them);
        let blockers = ours | theirs;
        let checkers = self.get_checkers();
        let pinrays = self.pinrays[us];
        let king_sq = self.kings(us).first();
        let in_check = checkers.count() > 0;
        let pinned_pieces = ours & pinrays;
        let promo_rank = self.get_promo_rank();

        let mut valid_targets = theirs;

        if in_check {
            valid_targets &= checkers;
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // King tacticals
        //
        ////////////////////////////////////////////////////////////////////////

        let targets = king_sq.king_squares() & valid_targets & !self.get_threats();

        for target in targets {
            moves.push(Move::new(king_sq, target, Capture));
        }

        // If we're in double check, only king moves are valid, so we exit 
        // early.
        if checkers.count() > 1 {
            return;
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // Piece tacticals
        //
        ////////////////////////////////////////////////////////////////////////

        for square in self.knights(us) & !pinned_pieces {
            let targets = square.knight_squares() & valid_targets;

            for target in targets {
                moves.push(Move::new(square, target, Capture));
            }
        }

        for square in self.bishops(us) {
            let mut targets = square.bishop_squares(blockers) & valid_targets;

            // If we're pinned, we can't move outside of our pin-ray
            if pinned_pieces.contains(square) {
                let pinray = pinrays & RAYS[king_sq][square];
                targets &= pinray;
            }

            for target in targets {
                moves.push(Move::new(square, target, Capture));
            }
        }

        for square in self.rooks(us) {
            let mut targets = square.rook_squares(blockers) & valid_targets;

            // If we're pinned, we can't move outside of our pin-ray
            if pinned_pieces.contains(square) {
                let pinray = pinrays & RAYS[king_sq][square];
                targets &= pinray;
            }

            for target in targets {
                moves.push(Move::new(square, target, Capture));
            }
        }

        for square in self.queens(us) {
            let mut targets = square.queen_squares(blockers) & valid_targets;

            // If we're pinned, we can't move outside of our pin-ray
            if pinned_pieces.contains(square) {
                let pinray = pinrays & RAYS[king_sq][square];
                targets &= pinray;
            }

            for target in targets {
                moves.push(Move::new(square, target, Capture));
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // Pawn tacticals
        //
        ////////////////////////////////////////////////////////////////////////

        for square in self.pawns(us) {
            let is_pinned = pinned_pieces.contains(square);

            let mut capture_targets = square.pawn_attacks(us) & valid_targets;
            let mut promo_targets = square.pawn_pushes(us, blockers) & promo_rank;

            // If we're pinned, we can't move outside of our pin-ray
            if is_pinned {
                let pinray = pinrays & RAYS[king_sq][square];
                capture_targets &= pinray;
                promo_targets &= pinray;
            }

            for target in capture_targets & !promo_rank {
                moves.push(Move::new(square, target, Capture));
            }

            for target in capture_targets & promo_rank {
                moves.push(Move::new(square, target, KnightPromoCapture));
                moves.push(Move::new(square, target, BishopPromoCapture));
                moves.push(Move::new(square, target, RookPromoCapture));
                moves.push(Move::new(square, target, QueenPromoCapture));
            }

            // Promotions
            if in_check {
                // In check, the only legal promotions block the checker
                let checker_sq = checkers.first();
                promo_targets &= BETWEEN[checker_sq][king_sq];
            }


            for target in promo_targets {
                moves.push(Move::new(square, target, KnightPromo));
                moves.push(Move::new(square, target, BishopPromo));
                moves.push(Move::new(square, target, RookPromo));
                moves.push(Move::new(square, target, QueenPromo));
            }
        }

        // Add potential en-passant moves, after making sure they don't lead
        // to discovered checks
        if self.en_passant.is_some() {
            self.en_passant_moves(moves)
        }
    }

    /// Generate all the legal quiet moves for the current board state
    pub fn quiets(&self, moves: &mut MoveList) {
        use MoveType::*;
        let us = self.current;
        let them = !us;
        let ours = self.occupied_by(us);
        let theirs = self.occupied_by(them);
        let blockers = ours | theirs;
        let checkers = self.get_checkers();
        let pinrays = self.pinrays[us];
        let king_sq = self.kings(us).first();
        let in_check = checkers.count() > 0;
        let pinned_pieces = ours & pinrays;
        let promo_rank = self.get_promo_rank();

        ////////////////////////////////////////////////////////////////////////
        //
        // King quiets
        //
        ////////////////////////////////////////////////////////////////////////

        let targets = king_sq.king_squares() & !self.get_threats() & !blockers;

        for target in targets {
            moves.push(Move::new(king_sq, target, Quiet));
        }

        // Add castling moves
        for ctype in self.legal_castles() {
            moves.push(ctype.king_move());
        }

        // If we're in double check, only king moves are valid, so we exit 
        // early.
        if checkers.count() > 1 {
            return;
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // Piece quiets
        //
        ////////////////////////////////////////////////////////////////////////
        
        let mut valid_targets = !blockers;

        if in_check {
            valid_targets &= BETWEEN[checkers.first()][king_sq];
        }

        for square in self.knights(us) & !pinned_pieces {
            let targets = square.knight_squares() & valid_targets;

            for target in targets {
                moves.push(Move::new(square, target, Quiet));
            }
        }

        for square in self.bishops(us) {
            let mut targets = square.bishop_squares(blockers) & valid_targets;

            // If we're pinned, we can't move outside of our pin-ray
            if pinned_pieces.contains(square) {
                let pinray = pinrays & RAYS[king_sq][square];
                targets &= pinray;
            }

            for target in targets {
                moves.push(Move::new(square, target, Quiet));
            }
        }

        for square in self.rooks(us) {
            let mut targets = square.rook_squares(blockers) & valid_targets;

            // If we're pinned, we can't move outside of our pin-ray
            if pinned_pieces.contains(square) {
                let pinray = pinrays & RAYS[king_sq][square];
                targets &= pinray;
            }

            for target in targets {
                moves.push(Move::new(square, target, Quiet));
            }
        }

        for square in self.queens(us) {
            let mut targets = square.queen_squares(blockers) & valid_targets;

            // If we're pinned, we can't move outside of our pin-ray
            if pinned_pieces.contains(square) {
                let pinray = pinrays & RAYS[king_sq][square];
                targets &= pinray;
            }

            for target in targets {
                moves.push(Move::new(square, target, Quiet));
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // Pawn quiets
        //
        ////////////////////////////////////////////////////////////////////////

        for square in self.pawns(us) {
            let mut push_targets = square.pawn_pushes(us, blockers) 
                & valid_targets 
                & !promo_rank;

            let mut dbl_push_targets = square.pawn_double_pushes(us, blockers) 
                & valid_targets;

            // If we're pinned, we can't move outside of our pin-ray
            if pinned_pieces.contains(square) {
                let pinray = pinrays & RAYS[king_sq][square];
                push_targets &= pinray;
                dbl_push_targets &= pinray;
            }

            // Push a move for every target square
            for target in push_targets {
                moves.push(Move::new(square, target, Quiet));
            }

            for target in dbl_push_targets {
                moves.push(Move::new(square, target, DoublePush));
            }
        }
    }

    /// Find all the legal moves for the current board state
    pub fn legal_moves<const ALL: bool>(&self) -> MoveList {
        let mut moves = MoveList::new();

        self.tacticals(&mut moves);

        if ALL {
            self.quiets(&mut moves);
        }

        moves
    }

    /// If there's a valid EP move, add it to the moves buffer
    fn en_passant_moves(&self, moves: &mut MoveList) {
        let us = self.current;
        let ep_sq = self.en_passant.unwrap();
        let checkers = self.checkers;
        let in_check = checkers.count() > 0;
        let attacked_pawn = ep_sq.backward(us).unwrap();
        let attacking_pawns = self.pawns(us) & ep_sq.pawn_attacks(!us);

        if in_check && !checkers.contains(attacked_pawn) {
            return;
        }

        for attacker in attacking_pawns {
            // Make sure the capture doesn't lead to a discovered check.
            let cleared_rank = RANKS[attacked_pawn.rank()];
            let source = Bitboard::from(attacker);
            let captured = Bitboard::from(attacked_pawn);
            let invisible = source | captured;
            let xray_checkers = self.xray_checkers(us, invisible);
            let exposes_check = (!xray_checkers & cleared_rank).is_empty();

            if !exposes_check {
                moves.push(Move::new(attacker, ep_sq, MoveType::EnPassant));
            }
        }
    }

    // Find a legal move corresponding to an un-annotated bare move, if any.
    pub fn find_move(&self, bare: BareMove) -> Option<Move> {
        let legals = self.legal_moves::<ALL>();
        legals.into_iter().find(|legal| legal.eq(&bare))
    }

    /// Check whether a move is legal to play in the current board position.
    ///
    /// This aims to be a lot cheaper than simply generating all the legal moves
    /// and checking whether the provided move is among them.
    ///
    /// This assumes the moves were generated by some kind of legal movegen. 
    /// For example, we assume that promotions and castling happen on the 
    /// 1st/8th ranks.
    pub fn is_legal(&self, mv: Move) -> bool {
        use MoveType::*;
        use PieceType::*;
        let us = self.current;
        let checkers = self.get_checkers();
        let num_checkers = checkers.count();
        let pinrays = self.get_pinrays(us);
        let blockers = self.all_occupied();
        let src = mv.src();
        let tgt = mv.tgt();

        // There is a piece on the starting square
        let Some(piece) = self.get_at(src) else { 
            return false;
        };

        // The piece is the correct color
        if piece.color() != us {
            return false;
        }

        // Make sure the move is pseudo-legal. 
        let attacked = match piece.piece_type() {
            Pawn => if mv.is_capture() {
                src.pawn_attacks(us)
            } else {
                src.pawn_squares(us, blockers)
            },
            Knight => src.knight_squares(),
            Bishop => src.bishop_squares(blockers),
            Rook => src.rook_squares(blockers),
            Queen => src.queen_squares(blockers),
            King => src.king_squares(),
        };

        if !attacked.contains(tgt) && !mv.is_castle() && !mv.is_en_passant() {
            return false;
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // Capture checks
        //
        ////////////////////////////////////////////////////////////////////////

        if mv.is_capture() {
            // Capture checks
            let Some(captured) = self.get_at(mv.get_capture_sq()) else {
                return false;
            };

            // If there's a captured piece, it must be the opponent's color
            if captured.color() == us {
                return false;
            }
        } else {
            if self.get_at(mv.get_capture_sq()).is_some() {
                return false;
            }
        }

        // Promotion checks
        if mv.is_promotion() {
            if !piece.is_pawn() {
                return false;
            }

            if !self.get_promo_rank().contains(tgt) {
                return false;
            }
        } else {
            if piece.is_pawn() && tgt.is_promo_rank(self.current) {
                return false;
            }
        }


        ////////////////////////////////////////////////////////////////////////
        //
        // En-passant checks
        //
        ////////////////////////////////////////////////////////////////////////

        if mv.is_en_passant() {
            if !piece.is_pawn() {
                return false;
            }

            if self.en_passant.is_some_and(|ep_sq| ep_sq != tgt) {
                return false;
            }

            if self.en_passant.is_some_and(|ep_sq| !attacked.contains(ep_sq)) {
                return false;
            }

            let Some(captured) = self.get_at(mv.get_capture_sq()) else {
                return false;
            };

            if !captured.is_pawn() {
                return false;
            }

            // Revealed checks
            let post_ep_blockers = blockers 
                ^ Bitboard::from(src)
                ^ Bitboard::from(tgt)
                ^ Bitboard::from(self.en_passant.unwrap());
            let king = self.kings(us).first();

            let post_ep_check = !(
                (king.rook_squares(post_ep_blockers) & self.hv_sliders(!us)).is_empty()
             && (king.bishop_squares(post_ep_blockers) & self.diag_sliders(!us)).is_empty()
            );

            if post_ep_check {
                return false;
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // Double push checks
        //
        ////////////////////////////////////////////////////////////////////////

        if mv.is_double_push() {
            if !piece.is_pawn() {
                return false;
            }
        } else {
            // A pawn move of 2 squares must be flagged as a double push
            if piece.is_pawn() && src.max_dist(tgt) == 2 {
                return false;
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // Castling checks
        //
        ////////////////////////////////////////////////////////////////////////

        if mv.is_castle() {
            use CastleType::*;

            // The move is a valid castle move
            let Some(ctype) = CastleType::from_move(mv) else {
                return false;
            };

            // The move flag matches the castle type
            match ctype {
                WK | BK if mv.get_type() != KingCastle => return false,
                WQ | BQ if mv.get_type() != QueenCastle => return false,
                _ => {}
            };

            // Can't castle when in check
            if num_checkers > 0 {
                return false;
            }

            // Castle must move the king
            if !piece.is_king() {
                return false;
            }

            // Castle must be available, unobstructed and not attacked
            if !self.legal_castles().contains(&ctype) {
                return false;
            }
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // King/legality checks
        //
        ////////////////////////////////////////////////////////////////////////
        
        // Only king moves allowed when double checked
        if num_checkers > 1 {
            if !piece.is_king() {
                return false;
            }
        }

        // If piece is pinned, make sure target square is inside pinray
        let king_sq = self.kings(self.current).first();

        if pinrays.contains(src) && !(pinrays & RAYS[king_sq][src]).contains(tgt) {
            return false;
        }

        // If in check, make sure the target square is between the king and the
        // checker
        if let Some(checker) = checkers.into_iter().next() {
            let king = self.kings(us).first();

            if !piece.is_king() && !BETWEEN[king][checker].contains(tgt) {
                return false;
            }
        }

        // King can't move into check
        if piece.is_king() && self.threats.contains(tgt) {
            return false;
        }

        true
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// Tests
//
////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use super::*;
    use crate::square::Square;
    use Square::*;
    

    #[test]
    fn double_pushes() {
        let board: Board = "rnbqkbnr/ppp1pppp/3p4/8/8/3P4/PPP1PPPP/RNBQKBNR w KQkq - 0 2"
            .parse()
            .unwrap();
        let legal_moves = board.legal_moves::<ALL>();

        // e2 can double-push
        assert!(legal_moves
            .iter()
            .find(|mv| mv.src() == Square::E2 && mv.tgt() == Square::E4 && mv.is_double_push())
            .is_some());

        // d3 can't double-push
        assert!(legal_moves
            .iter()
            .find(|mv| mv.src() == Square::D3 && mv.tgt() == Square::D5)
            .is_none());
    }

    #[test]
    fn pieces_must_block_to_counter_checks() {
        let board: Board = "1k6/8/8/5q2/8/8/4R3/1K6 w - - 0 1".parse().unwrap();
        let legal_moves = board.legal_moves::<ALL>();

        let rook_moves: Vec<Move> = legal_moves
            .into_iter()
            .filter(|mv| mv.src() == Square::E2)
            .collect();

        // Only two legal moves: block on c2 or e4
        assert_eq!(rook_moves.len(), 2);
        assert!(rook_moves
            .iter()
            .find(|mv| mv.tgt() == Square::C2)
            .is_some());
        assert!(rook_moves
            .iter()
            .find(|mv| mv.tgt() == Square::E4)
            .is_some())
    }

    #[test]
    fn king_must_move_out_of_check() {
        let board: Board = "1k6/8/8/5q2/8/3K4/8/8 w - - 0 1".parse().unwrap();
        let king_moves: Vec<Move> = board
            .legal_moves::<ALL>()
            .into_iter()
            .filter(|mv| mv.src() == Square::D3)
            .collect();

        // Only king moves are getting out of check
        assert_eq!(king_moves.len(), 6);
        assert!(king_moves
            .iter()
            .find(|mv| mv.tgt() == Square::E4)
            .is_none());
        assert!(king_moves
            .iter()
            .find(|mv| mv.tgt() == Square::C2)
            .is_none());
    }

    #[test]
    fn check_blocks_and_king_moves_combined() {
        let board: Board = "1k6/8/8/5q2/8/4P3/PP5r/RK6 w - - 0 1".parse().unwrap();
        let legal_moves = board.legal_moves::<ALL>();
        let king_moves: Vec<&Move> = legal_moves
            .iter()
            .filter(|mv| mv.src() == Square::B1)
            .collect();

        let pawn_moves: Vec<&Move> = legal_moves
            .iter()
            .filter(|mv| mv.src() == Square::E3)
            .collect();

        // Only legal moves are Kc1 and e4
        assert_eq!(legal_moves.len(), 2);

        // King's only move is c1
        assert_eq!(king_moves.len(), 1);
        assert_eq!(king_moves.first().unwrap().tgt(), Square::C1);

        // Pawn's only move is e4
        assert_eq!(pawn_moves.len(), 1);
        assert_eq!(pawn_moves.first().unwrap().tgt(), Square::E4);
    }

    #[test]
    fn pins() {
        let board: Board = "1k6/2q5/8/1n6/5B2/1R6/8/1K6 b - - 0 1".parse().unwrap();
        let legal_moves = board.legal_moves::<ALL>();

        let knight_moves: Vec<&Move> = legal_moves.iter().filter(|mv| mv.src() == B5).collect();

        let queen_moves: Vec<&Move> = legal_moves.iter().filter(|mv| mv.src() == C7).collect();

        // Knight is completely pinned
        assert_eq!(knight_moves.len(), 0);

        // Queen can move within the pin ray
        assert_eq!(queen_moves.len(), 3);
    }

    #[test]
    fn en_passant() {
        let board: Board = "1k6/8/8/8/3Pp3/8/8/1K6 b - d3 0 1".parse().unwrap();
        let legal_moves = board.legal_moves::<ALL>();

        let pawn_moves: Vec<&Move> = legal_moves.iter().filter(|mv| mv.src() == E4).collect();

        assert_eq!(pawn_moves.len(), 2, "there are two legal pawn moves from e4");

        let en_passant = pawn_moves.iter().find(|mv| mv.tgt() == D3);
        assert!(en_passant.is_some(), "We can capture en-passant");
        assert!(
            en_passant.unwrap().is_en_passant(),
            "The en-passant flag is set"
        );
    }

    #[test]
    fn en_passant_revealed_check() {
        let board: Board = "8/8/8/8/k2Pp2R/8/8/K7 b - d3 0 1".parse().unwrap();
        let legal_moves = board.legal_moves::<ALL>();

        let pawn_moves: Vec<&Move> = legal_moves.iter().filter(|mv| mv.src() == E4).collect();

        let en_passant = pawn_moves.iter().find(|mv| mv.tgt() == D3);
        assert!(
            en_passant.is_none(),
            "En-passant not allowed if it reveals a check"
        );
    }
}
